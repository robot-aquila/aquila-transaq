SDS - Security Data Service

Определения:

* GID (SymbolGID) - Генеральный идентификатор инструмента, с помощью которого
  решается проблема дублирования кодов некоторых инструментов MOEX/TRANSAQ. Указывает
  на инструмент в целом, без учета торговой секции, где он может торговаться.
* TID (SymbolTID) - Торговый идентификатор инструмента (см. GID), который
  сопровождается информацией о торговой секции, на которой торгуется инструмент.

????
Может GID заменить на Symbol с пустым эксчейнджем?
Тогда нужно будет обеспечить конвертацию:
*) SecIDG -> GSymbol
*) SecIDT -> GSymbol
*) SecIDT -> GSymbol
*) GSymbol -> SecIDG
*) TSymbol -> SecIDG
*) TSymbol -> SecIDT
С определеннием маркета проблем быть не должно - по коду эксчейнджа.

Так, вылезла проблема - ключи сущностей у нас ведь GID и TID. Также придется менять.

Насчет того, что exchangeID=null - это соглашение, можно унаследовать от символа
новый класс специально для наглядности.

А можно сделать еще лучше. Унаследовать от Symbol два класса. Исключительно для образования
двух взаимоисключающих типов в целях разделения типов в интерфейсах и исключения разночтения.
Если поправить метод equals с целью проверки соответствия класса, то будет еще надежнее.
Конвертировать одно в другое вроде как несложно. В таблице маркетов есть коды. В таблице
бордов есть айдишки маркетов.

Q.А зачем нам маркет?
A. Маркет используется как часть ключа, однозначно идентифицирующий инструмент.
Вообще это логично, так как один и тот же код бумаги используется на разных рынках.
Например, SBER@MOEX, SBER@LSE. Так что маркет нужен, что бы избежать разночтения раз
и навсегда. Просто вместо числового ID мы будем использовать символьный.

????

- Нода - дополнительная сущность, группирующая все инструменты по GID.


Проблемы:

1) На момент поступления подписки нет соединения и проверить наличие инструмента нет возможности.
2) При генеральном обновлении инструмента нужно обновлять экземпляры на всех бордах.
3) Для фьючей и опционов комбинация кода и секции повторяется каждую декаду.

----
TODO:

1) добавить атрибут currency и при парсинге определять
2) добавить валиаторы что бы проверял валюту и тип инструмента - должны быть!
3) с хранилищем просто юзать GID, TID как ключи. При ротации кодов просто другой GID/TID будет
4) После реконнекта нужно полностью перестроить стаканы. Но при этом
   терять текущее состояние стакана на период отсутствия подключения не хочется.
   Нужно продумать и согласовать коннект/дисконнект с обработкой апдейтов MD.
   !!!Возможно в MDUpdate придется добавить инструкцию очистки стакана.
5) Еще проблема такая по поводу статусов фидов. Они сейчас на базе SecIDT. Значит сейчас
   внутри этого кэша возникает проблема с ротацией кодов в связи со статусами фидов. Просто это
   никак не решить. Варианты:
	- ассоциировать статусы фидов с Symbol. Проверять при синхронизации статусов, отписываться при
	  изменении (требуется продумать)
	- сменить ключ статуса фидов на TID. Идеологически менее корректно, так как статус фидов это именно
	  состояние под TRANSAQ-овским ключам.
----
Триггеры:

1) Соединение установлено
2) Соединение потеряно
3) Запрос на подписку
4) Отмена подписки
5) Обновление генеральной сущности инструмента
6) Обновление параметров борда инструмента
7) Обновление L1 (quotation)
8) Обновление L1 (сделка)
9) Обновление L2 (quote)

===============================================================================
Триггер: Соединение установлено

Этапы:

1) Для каждого символа из списка счетчиков:
	- Проверить наличие инструмента по таблицам сущностей TRANSAQ
	- Сформировать атрибуты инструмента на основании сущностей TRANSAQ
	- Синхронизировать состояния фидов инструмента со счетчиками подписок
2) Обработать подписки в статусе PENDING

===============================================================================
Триггер: Соединение потеряно

Этапы:

1) Для каждого экземпляра состояния фидов сбросить статусы всех фидов в NOT_SUBSCR

===============================================================================
Триггер: Запрос на подписку

Состояния:
1) Инструмент может существовать - символ прошел первичную валидацию
2) Инструмент точно существует:
	- прошел первичную
	- имеются соответствующие сущности в таблицах
3) Инструмент точно не существует:
	- не прошел первичную валидацию
	- отсутствуют соответствующие сущности в таблицах TRANSAQ

В комбинации с состоянием коннекта
1) Подключено
2) Не подключено

Варианты действий:

1.1;2.1) Инструмент может существовать/существует + Подключено
	- Проверить валидность символа
	- Увеличить счетчики подписок
	- Проверить наличие инструмента по таблицам сущностей TRANSAQ
	- Сформировать атрибуты инструмента на основании сущностей TRANSAQ
	- Синхронизировать состояния фидов инструмента со счетчиками подписок
	- Обработать подписки в статусе PENDING

1.2;2.2) Инструмент может существовать/существует + Не подключено
	- Проверить валидность символа
	- Увеличить счетчики подписок

3.1) Инструмент точно не существует + Подключено (например, не совпадает валюта или тип)
	- Проверить валидность символа

3.2) Инструмент точно не существует + Не подключено (не указаны валюта и тип)
	- Проверить валидность символа

===============================================================================
Триггер: Отмена подписки

Считаем, что инструмент гарантированно существует (метод доступен только
локально). Варианты ограничены только состоянием коннекта.

1) Подключено
2) Не подключено

Варианты действий:

1) Подключено
	- Уменьшить счетчик подписок
	- Синхронизировать состояние фидов со счетчиками подписок
	- Обработать подписки в статусе PENDING

2) Не подключено
	- Уменьшить счетчик подписок

===============================================================================
Триггер: Обновление генеральной сущности инструмента

- все инструменты, связанные с этим GID, уже существуют в ноде GIDа
- кейс, когда в ноду нужно добавить новый инструмент отсутствует, так как:
	- нет TIDа
	- если речь о потенциальных неучтенных сабскрайберах по счетчикам, то не
	  релевантно, так как инструменты добавляются либо на сабскрайбе, либо на
	  коннекте. Неучтенные могут быть только при отсутствии коннекта, а при
	  отсутствии коннекта ничего не делаем
- В таблицах сущностей Security Params и Security Board Params у нас ключи
  соответственно GID и TID, а это значит, что проблема дублирущихся кодов
  отпадает (ТОЛЬКО при определении ноды) на этапах определения GID и TID (то
  есть здесь проблема не актуальна).
- Отсюда нужно решать проблему ротации кодов (когда у SecIDT меняется GID) при
  учете TRANSAQ подписок. Нужно проверить, какой GID у текущего статуса подписок.
  Учитывать, что статуса подписок может не существовать на момент вызова.


1) При наличии коннекта
	- перебрать все инструменты закешированные в (ноде по GIDу) и обновить для
	  них атрибуты на основании общего Security Params и индивидуального
	  Security Board Params.


===============================================================================
Триггер: Обновление параметров борда инструмента

1) При наличии коннекта
	- Сформировать атрибуты инструмента на основании сущностей TRANSAQ

===============================================================================
Триггер: Обновление L1 (quotation)

Здесь некоторая сложность может возникнуть с определением BBO. Рассмотрим вариант
с опорой на измененные токены. BBO это не аггрегируемые данные. В отличии
от сделок, каждая из которых важна, поскольку потеря сделки приведет к уменьшению
агрегиррованных данных типа количество сделок, объем торгов, средняя цена и т.п.
Для Ask/Bid достаточно генерировать апдейты только когда хотя бы одно из значимых
полей было изменено. -> С опорой на измененные токены работать будет.

Q. Почему выбран не очень вариант?
A. Приходится полагаться на то, этот вызов осуществляется своевременно. Но нет
гарантии, что кто либо не вклинится и не сделает два или более промежуточных
апдейтов. Если так, то после "нужного" апдейта список измененных токенов
потеряется и триггер не сработает. 

Значит TQStateUpdate. Остается только вопрос, кто должен апдейтить директории?
Скорее всего этот сервис и будет апдейтить.

===============================================================================
Триггер: Обновление L1 (сделка)

К сожалению, L1Update в качестве аргумента не очень подходит из за необходимости
снаружи определять Symbol. Может Tick? А может L1UpdateBuilder? По моему
L1UpdateBuilder оптимально. При билде он выкинет исключение, если символ
неопределен.

Q. В чем проблема с определением символа снаружи? 
A. Подразумевается, что билдер будет заполнять парсер. А на этапе
парсинга никакой возможности конвертнуть в символ нет.

Q. Почему передавать L1UpdateBuilder не очень идея?
A. Образуется зависимость от hi-end объекта, использование которого лишает нас
возможности обрабатывать специфические данные (возможные изменения TRANSAQ API)
в рамках сервиса.

Значит TQStateUpdate...

===============================================================================
Триггер: Обновление L2 (quote)
Аргументы: TID, MDUpdateBuilder

Используем список TQStateUpdate для построения MDUpdate. Не забываем учитывать
необходимость полной перестройки стакана после реконнекта.
