SDS - Security Data Service

Определения:

* GID (SymbolGID) - Генеральный идентификатор инструмента, с помощью которого
  решается проблема дублирования кодов некоторых инструментов MOEX/TRANSAQ. Указывает
  на инструмент в целом, без учета торговой секции, где он может торговаться.
* TID (SymbolTID) - Торговый идентификатор инструмента (см. GID), который
  сопровождается информацией о торговой секции, на которой торгуется инструмент.

????
Может GID заменить на Symbol с пустым эксчейнджем?
Тогда нужно будет обеспечить конвертацию:
*) SecIDG -> GSymbol
*) SecIDT -> GSymbol
*) SecIDT -> GSymbol
*) GSymbol -> SecIDG
*) TSymbol -> SecIDG
*) TSymbol -> SecIDT
С определеннием маркета проблем быть не должно - по коду эксчейнджа.

Так, вылезла проблема - ключи сущностей у нас ведь GID и TID. Также придется менять.

Насчет того, что exchangeID=null - это соглашение, можно унаследовать от символа
новый класс специально для наглядности.

А можно сделать еще лучше. Унаследовать от Symbol два класса. Исключительно для образования
двух взаимоисключающих типов в целях разделения типов в интерфейсах и исключения разночтения.
Если поправить метод equals с целью проверки соответствия класса, то будет еще надежнее.
Конвертировать одно в другое вроде как несложно. В таблице маркетов есть коды. В таблице
бордов есть айдишки маркетов.

Q.А зачем нам маркет?
A. Маркет используется как часть ключа, однозначно идентифицирующий инструмент.
Вообще это логично, так как один и тот же код бумаги используется на разных рынках.
Например, SBER@MOEX, SBER@LSE. Так что маркет нужен, что бы избежать разночтения раз
и навсегда. Просто вместо числового ID мы будем использовать символьный.

????

- Нода - дополнительная сущность, группирующая все инструменты по GID.


Проблемы:

1) На момент поступления подписки нет соединения и проверить наличие инструмента нет возможности.
2) При генеральном обновлении инструмента нужно обновлять экземпляры на всех бордах.
3) Для фьючей и опционов комбинация кода и секции повторяется каждую декаду.

Дурацкую проблему ротации кодов нужно решить по-тупому. По сути там делать особо ничего не нужно.
State of data feeds определяется по символу. И если символ не дает актуального TID, то никаких
действий в отношении фида не выполняется. При потере коннекта статусы фидов сбрасываются.
И будут восстановлены только при реконнекте и только в случае если для актуального символа
есть подписчики. Остается фантастический вариант, когда программа проработала 10 лет без
реконнекта и при этом постоянно висела подписка на фид TIDа, которые ротнулся. По сути это вообще
не наши проблемы. Пусть остается как есть. Обработчики апдейтов конвертнут TID в актуальные айдишки.
Остается вопрос - если приходят апдейты по инструментам, которых как бы нет. Что делать?
Усложнять обработчик коннекта или создавать любые инструменты на лету?

Создавать любые инструменты на-лету не вариант, так как основные апдейты приходят без пописки.
При получении параметров инструментов и параметров борда нужно как то проверять необходимость
работы с локальными инструментами.

1) Когда речь идет об обновлении борда, то понятно: делаем TID -> TSymbol -> Symbol и проверяем
положительный счетчик в реестре счетчиков.
2) В случае обновления дженерал инструмента немного сложнее. Мы точно знаем, что никаких валидных
инструментов, кроме тех что связанны с соответствующими бордами нет. Значит можно получить
пул символов, на основании  GID и известных бордов. Замет по этому списку проверить реестр счетчиков
и поработать с теми инструментами, для которых положительный L0.

С другой стороны, у нас проблема с ротацией кодов и текущим статусом фида где может проявиться?
На коннекте оно не вылезет, так как там все заново переподписывается (пока еще непонятно, будет
это работать нормально или нет). Значит остается два места, где идет синхронизация статуса фидов
со счетчиками: это подписка и отписка.

Предположим, что это первичная подписка на Symbol при уже открытом фиде на TID, но подразумевалось
что это было для предыдущего Symbol. Будет создано новое состояние фидов для которого все отписано.
Так как счетчик будет увеличен, при синке будет запрос на подписку. Итого получаем повторную
подписку (в худшем случае).

Предположим, что это последняя отписка от Symbol в ситуации, когда счетчик был увеличен в тот период,
когда TID соответствовал другому Symbol. То есть, фактически фид открыт для другого инструмента.
Получим отписку от не того инструмента. Но это в общем то не страшно.

Вариант, когда декремент счетчика и создается новый статус, а результат предыдущей подписки на фид
теряется не может быть. Так как статусы фидов существуют независимо от символов. Кароче вроде бы все
нормально. Единственный момент, будет типа зависший фид, но это не наши проблемы. 

Итого: статусы фидов вообще не трогаем, так как они сами по себе. ТАМ МОЖЕТ ВЫЛЕЗТИ ПРОБЛЕМА
перехода по состояниям. Но мы их протестим [===TEST_CASE===]!!!!!

??????

----
TODO:

1) добавить атрибут currency и при парсинге определять
2) добавить валиаторы что бы проверял валюту и тип инструмента - должны быть!
3) с хранилищем просто юзать GID, TID как ключи. При ротации кодов просто другой GID/TID будет
4) После реконнекта нужно полностью перестроить стаканы. Но при этом
   терять текущее состояние стакана на период отсутствия подключения не хочется.
   Нужно продумать и согласовать коннект/дисконнект с обработкой апдейтов MD.
   !!!Возможно в MDUpdate придется добавить инструкцию очистки стакана.
5) Еще проблема такая по поводу статусов фидов. Они сейчас на базе SecIDT. Значит сейчас
   внутри этого кэша возникает проблема с ротацией кодов в связи со статусами фидов. Просто это
   никак не решить. Варианты:
	- ассоциировать статусы фидов с Symbol. Проверять при синхронизации статусов, отписываться при
	  изменении (требуется продумать)
	- сменить ключ статуса фидов на TID. Идеологически менее корректно, так как статус фидов это именно
	  состояние под TRANSAQ-овским ключам.
----
Триггеры:

1) Соединение установлено
2) Соединение потеряно
3) Запрос на подписку
4) Отмена подписки
5) Обновление генеральной сущности инструмента
6) Обновление параметров борда инструмента
7) Обновление L1 (quotation)
8) Обновление L1 (сделка)
9) Обновление L2 (quote)

===============================================================================
Триггер: Соединение установлено

Этапы:

1) Для каждого символа из списка счетчиков:
	- Проверить наличие инструмента по таблицам сущностей TRANSAQ
	- Сформировать атрибуты инструмента на основании сущностей TRANSAQ
	- Синхронизировать состояния фидов инструмента со счетчиками подписок
2) Обработать подписки в статусе PENDING

===============================================================================
Триггер: Соединение потеряно

Этапы:

1) Для каждого экземпляра состояния фидов сбросить статусы всех фидов в NOT_SUBSCR

===============================================================================
Триггер: Запрос на подписку

Состояния:
1) Инструмент может существовать - символ прошел первичную валидацию
2) Инструмент точно существует:
	- прошел первичную
	- имеются соответствующие сущности в таблицах
3) Инструмент точно не существует:
	- не прошел первичную валидацию
	- отсутствуют соответствующие сущности в таблицах TRANSAQ

В комбинации с состоянием коннекта
1) Подключено
2) Не подключено

Варианты действий:

1.1;2.1) Инструмент может существовать/существует + Подключено
	- Проверить валидность символа
	- Увеличить счетчики подписок
	- Проверить наличие инструмента по таблицам сущностей TRANSAQ
	- Сформировать атрибуты инструмента на основании сущностей TRANSAQ
	- Синхронизировать состояния фидов инструмента со счетчиками подписок
	- Обработать подписки в статусе PENDING

1.2;2.2) Инструмент может существовать/существует + Не подключено
	- Проверить валидность символа
	- Увеличить счетчики подписок

3.1) Инструмент точно не существует + Подключено (например, не совпадает валюта или тип)
	- Проверить валидность символа

3.2) Инструмент точно не существует + Не подключено (не указаны валюта и тип)
	- Проверить валидность символа

===============================================================================
Триггер: Отмена подписки

Считаем, что инструмент гарантированно существует (метод доступен только
локально). Варианты ограничены только состоянием коннекта.

1) Подключено
2) Не подключено

Варианты действий:

1) Подключено
	- Уменьшить счетчик подписок
	- Синхронизировать состояние фидов со счетчиками подписок
	- Обработать подписки в статусе PENDING

2) Не подключено
	- Уменьшить счетчик подписок

===============================================================================
Триггер: Обновление генеральной сущности инструмента

- все инструменты, связанные с этим GID, уже существуют в ноде GIDа
- кейс, когда в ноду нужно добавить новый инструмент отсутствует, так как:
	- нет TIDа
	- если речь о потенциальных неучтенных сабскрайберах по счетчикам, то не
	  релевантно, так как инструменты добавляются либо на сабскрайбе, либо на
	  коннекте. Неучтенные могут быть только при отсутствии коннекта, а при
	  отсутствии коннекта ничего не делаем
- В таблицах сущностей Security Params и Security Board Params у нас ключи
  соответственно GID и TID, а это значит, что проблема дублирущихся кодов
  отпадает (ТОЛЬКО при определении ноды) на этапах определения GID и TID (то
  есть здесь проблема не актуальна).
- -=НЕ НАДО ЕЕ РЕШАТЬ!=- Отсюда нужно решать проблему ротации кодов (когда у
  SecIDT меняется GID) при учете TRANSAQ подписок. Нужно проверить, какой GID у
  текущего статуса подписок. Учитывать, что статуса подписок может не
  существовать на момент вызова. -= Все нормально будет. Статусы фидов
  отдельно от всего =-


1) При наличии коннекта
	- перебрать все инструменты закешированные в (ноде по GIDу) и обновить для
	  них атрибуты на основании общего Security Params и индивидуального
	  Security Board Params.
^^^ Здесь более сложно. Возможно настало время создать локальный инструмент.
Надо узнать по каким подходящим символам по L0 больше нуля счетчики и для них
инициировать процесс создания инструмента и копирования данных.


===============================================================================
Триггер: Обновление параметров борда инструмента

1) При наличии коннекта
	- Сформировать атрибуты инструмента на основании сущностей TRANSAQ

===============================================================================
Триггер: Обновление L1 (quotation)

Здесь некоторая сложность может возникнуть с определением BBO. Рассмотрим вариант
с опорой на измененные токены. BBO это не аггрегируемые данные. В отличии
от сделок, каждая из которых важна, поскольку потеря сделки приведет к уменьшению
агрегиррованных данных типа количество сделок, объем торгов, средняя цена и т.п.
Для Ask/Bid достаточно генерировать апдейты только когда хотя бы одно из значимых
полей было изменено. -> С опорой на измененные токены работать будет.

Q. Почему выбран не очень вариант?
A. Приходится полагаться на то, этот вызов осуществляется своевременно. Но нет
гарантии, что кто либо не вклинится и не сделает два или более промежуточных
апдейтов. Если так, то после "нужного" апдейта список измененных токенов
потеряется и триггер не сработает. 

Значит TQStateUpdate. Остается только вопрос, кто должен апдейтить директории?
Скорее всего этот сервис и будет апдейтить.

===============================================================================
Триггер: Обновление L1 (сделка)

К сожалению, L1Update в качестве аргумента не очень подходит из за необходимости
снаружи определять Symbol. Может Tick? А может L1UpdateBuilder? По моему
L1UpdateBuilder оптимально. При билде он выкинет исключение, если символ
неопределен.

Q. В чем проблема с определением символа снаружи? 
A. Подразумевается, что билдер будет заполнять парсер. А на этапе
парсинга никакой возможности конвертнуть в символ нет.

Q. Почему передавать L1UpdateBuilder не очень идея?
A. Образуется зависимость от hi-end объекта, использование которого лишает нас
возможности обрабатывать специфические данные (возможные изменения TRANSAQ API)
в рамках сервиса.

Значит TQStateUpdate...

===============================================================================
Триггер: Обновление L2 (quote)
Аргументы: TID, MDUpdateBuilder

Используем список TQStateUpdate для построения MDUpdate. Не забываем учитывать
необходимость полной перестройки стакана после реконнекта.
